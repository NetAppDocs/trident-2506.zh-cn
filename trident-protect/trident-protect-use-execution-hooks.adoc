---
sidebar: sidebar 
permalink: trident-protect/trident-protect-use-execution-hooks.html 
keywords: trident, protect, execution hooks 
summary: 您可以使用Trident Protect 为应用程序创建自定义执行钩子。您需要拥有所有者、管理员或成员权限才能创建执行钩子。 
---
= 管理Trident Protect 执行钩子
:hardbreaks:
:allow-uri-read: 
:nofooter: 
:icons: font
:linkattrs: 
:imagesdir: ../media/


[role="lead"]
执行钩子是一种自定义操作，您可以将其配置为与受管应用程序的数据保护操作一起运行。例如，如果您有一个数据库应用程序，则可以使用执行挂钩在快照之前暂停所有数据库事务，并在快照完成后恢复事务。这确保了应用程序一致的快照。



== 执行钩子的类型

Trident Protect 支持以下几种执行钩子类型，具体取决于它们的运行时机：

* 预快照
* 快照后
* 预备份
* 备份后
* 恢复后
* 故障转移后




=== 执行顺序

当运行数据保护操作时，执行挂钩事件按以下顺序发生：

. 任何适用的自定义预操作执行挂钩都在适当的容器上运行。您可以根据需要创建和运行任意数量的自定义预操作挂钩，但这些挂钩在操作之前的执行顺序既无法保证也无法配置。
. 如果适用，则会发生文件系统冻结。link:trident-protect-requirements.html#protecting-data-with-kubevirt-vms["了解更多关于使用Trident Protect 配置文件系统冻结的信息"]。
. 执行数据保护操作。
. 如果适用，冻结的文件系统将被解冻。
. 任何适用的自定义后操作执行挂钩都在适当的容器上运行。您可以根据需要创建和运行任意数量的自定义后操作挂钩，但操作后这些挂钩的执行顺序既无法保证也无法配置。


如果您创建多个相同类型的执行挂钩（例如，预快照），则无法保证这些挂钩的执行顺序。但是，不同类型的钩子的执行顺序是有保证的。例如，以下是具有所有不同类型钩子的配置的执行顺序：

. 快照前钩子执行
. 快照后钩子执行
. 执行备份前挂钩
. 执行备份后钩子



NOTE: 前面的顺序示例仅适用于运行不使用现有快照的备份时。


NOTE: 在生产环境中启用执行挂钩脚本之前，您应该始终对其进行测试。您可以使用“kubectl exec”命令方便地测试脚本。在生产环境中启用执行挂钩后，测试生成的快照和备份以确保它们一致。您可以通过将应用程序克隆到临时命名空间、恢复快照或备份，然后测试应用程序来执行此操作。


NOTE: 如果快照前执行钩子添加、更改或删除 Kubernetes 资源，则这些更改将包含在快照或备份以及任何后续恢复操作中。



== 关于自定义执行钩子的重要说明

在为您的应用程序规划执行挂钩时，请考虑以下事项。

* 执行钩子必须使用脚本来执行操作。许多执行钩子可以引用同一个脚本。
* Trident Protect 要求执行钩子使用的脚本以可执行 shell 脚本的格式编写。
* 脚本大小限制为 96KB。
* Trident Protect 使用执行钩子设置和任何匹配条件来确定哪些钩子适用于快照、备份或恢复操作。



NOTE: 由于执行钩子通常会减少或完全禁用其所针对的应用程序的功能，因此您应该始终尝试尽量减少自定义执行钩子的运行时间。如果您启动带有相关执行挂钩的备份或快照操作，但随后取消它，则如果备份或快照操作已经开始，则仍允许挂钩运行。这意味着备份后执行挂钩中使用的逻辑不能假定备份已完成。



== 执行钩子过滤器

当您为应用程序添加或编辑执行挂钩时，您可以向执行挂钩添加过滤器来管理该挂钩将匹配哪些容器。过滤器对于在所有容器上使用相同容器镜像但可能将每个镜像用于不同目的的应用程序（例如 Elasticsearch）很有用。过滤器允许您创建执行挂钩在某些（但不一定是所有）相同的容器上运行的场景。如果为单个执行挂钩创建多个过滤器，它们将通过逻辑 AND 运算符组合在一起。每个执行挂钩最多可以有 10 个活动过滤器。

添加到执行挂钩的每个过滤器都使用正则表达式来匹配集群中的容器。当钩子与容器匹配时，钩子将在该容器上运行其关联的脚本。过滤器的正则表达式使用正则表达式 2 (RE2) 语法，该语法不支持创建从匹配列表中排除容器的过滤器。有关Trident Protect 在执行钩子过滤器中支持的正则表达式语法的详细信息，请参阅 https://github.com/google/re2/wiki/Syntax["正则表达式 2 (RE2) 语法支持"^]。


NOTE: 如果将命名空间过滤器添加到在恢复或克隆操作后运行的执行挂钩，并且恢复或克隆源和目标位于不同的命名空间中，则命名空间过滤器仅适用于目标命名空间。



== 执行钩子示例

访问 https://github.com/NetApp/Verda["NetApp Verda GitHub 项目"]下载流行应用程序（如 Apache Cassandra 和 Elasticsearch）的真实执行挂钩。您还可以查看示例并获得构建您自己的自定义执行挂钩的想法。



== 创建执行钩子

您可以使用以下方法为应用程序创建自定义执行钩子。您需要拥有所有者、管理员或成员权限才能创建执行钩子。

[role="tabbed-block"]
====
.使用 CR
--
.步骤
. 创建自定义资源 (CR) 文件并将其命名为 `trident-protect-hook.yaml`。
. 配置以下属性以匹配您的Trident Protect 环境和集群配置：
+
** *metadata.name*: (_必填_) 此自定义资源的名称；请为您的环境选择一个唯一且有意义的名称。
** *spec.applicationRef*: (_必需_) 要运行执行钩子的应用程序的 Kubernetes 名称。
** *spec.stage*: (_Required_) 一个字符串，指示执行钩子应该在操作的哪个阶段运行。可能值：
+
*** 预
*** 发布


** *spec.action*: (_Required_) 一个字符串，指示执行钩子将采取什么操作，假设指定的任何执行钩子过滤器都匹配。可能值：
+
*** Snapshot
*** 备份
*** 还原
*** 故障转移


** *spec.enabled*: (_可选_) 指示此执行钩子是否已启用或禁用。如果未指定，则默认值为 true。
** *spec.hookSource*: (_必需_) 包含 base64 编码的 hook 脚本的字符串。
** *spec.timeout*: (_可选_) 定义执行钩子允许运行的分钟数的数字。最小值为 1 分钟，如果未指定，则默认值为 25 分钟。
** *spec.arguments*: (_可选_) 一个 YAML 列表，用于指定执行钩子的参数。
** *spec.matchingCriteria*: (_可选_) 一个可选的条件键值对列表，每个键值对构成一个执行钩子过滤器。每个执行钩子最多可以添加 10 个过滤器。
** *spec.matchingCriteria.type*: (_可选_) 用于标识执行钩过滤器类型的字符串。可能值：
+
*** 容器图像
*** 容器名称
*** Pod名称
*** PodLabel
*** 命名空间名称


** *spec.matchingCriteria.value*: (_可选_) 用于标识执行钩过滤器值的字符串或正则表达式。
+
YAML 示例：

+
[source, yaml]
----
apiVersion: protect.trident.netapp.io/v1
kind: ExecHook
metadata:
  name: example-hook-cr
  namespace: my-app-namespace
  annotations:
    astra.netapp.io/astra-control-hook-source-id: /account/test/hookSource/id
spec:
  applicationRef: my-app-name
  stage: Pre
  action: Snapshot
  enabled: true
  hookSource: IyEvYmluL2Jhc2gKZWNobyAiZXhhbXBsZSBzY3JpcHQiCg==
  timeout: 10
  arguments:
    - FirstExampleArg
    - SecondExampleArg
  matchingCriteria:
    - type: containerName
      value: mysql
    - type: containerImage
      value: bitnami/mysql
    - type: podName
      value: mysql
    - type: namespaceName
      value: mysql-a
    - type: podLabel
      value: app.kubernetes.io/component=primary
    - type: podLabel
      value: helm.sh/chart=mysql-10.1.0
    - type: podLabel
      value: deployment-type=production
----


. 在用正确的值填充 CR 文件后，应用 CR：
+
[source, console]
----
kubectl apply -f trident-protect-hook.yaml
----


--
.使用 CLI
--
.步骤
. 创建执行钩子，将括号中的值替换为您环境中的信息。例如：
+
[source, console]
----
tridentctl-protect create exechook <my_exec_hook_name> --action <action_type> --app <app_to_use_hook> --stage <pre_or_post_stage> --source-file <script-file> -n <application_namespace>
----


--
====


== 手动运行执行钩子

您可以手动运行执行钩子进行测试，或者在失败后需要手动重新运行钩子时也可以这样做。您需要拥有所有者、管理员或成员权限才能手动运行执行钩子。

手动运行执行钩子包含两个基本步骤：

. 创建资源备份，该备份会收集资源并创建它们的备份，从而确定钩子函数的运行位置。
. 针对备份运行执行钩子


.步骤 1：创建资源备份
[%collapsible]
====
[role="tabbed-block"]
=====
.使用 CR
--
.步骤
. 创建自定义资源 (CR) 文件并将其命名为 `trident-protect-resource-backup.yaml`。
. 配置以下属性以匹配您的Trident Protect 环境和集群配置：
+
** *metadata.name*: (_必填_) 此自定义资源的名称；请为您的环境选择一个唯一且有意义的名称。
** *spec.applicationRef*: (_必需_) 要为其创建资源备份的应用程序的 Kubernetes 名称。
** *spec.appVaultRef*: (_必需_) 存储备份内容的 AppVault 的名称。
** *spec.appArchivePath*: AppVault 内存储备份内容的路径。您可以使用以下命令查找此路径：
+
[source, console]
----
kubectl get backups <BACKUP_NAME> -n my-app-namespace -o jsonpath='{.status.appArchivePath}'
----
+
YAML 示例：

+
[source, yaml]
----
---
apiVersion: protect.trident.netapp.io/v1
kind: ResourceBackup
metadata:
  name: example-resource-backup
spec:
  applicationRef: my-app-name
  appVaultRef: my-appvault-name
  appArchivePath: example-resource-backup
----


. 在用正确的值填充 CR 文件后，应用 CR：
+
[source, console]
----
kubectl apply -f trident-protect-resource-backup.yaml
----


--
.使用 CLI
--
.步骤
. 创建备份，将括号中的值替换为您环境中的信息。例如：
+
[source, console]
----
tridentctl protect create resourcebackup <my_backup_name> --app <my_app_name> --appvault <my_appvault_name> -n <my_app_namespace> --app-archive-path <app_archive_path>
----
. 查看备份状态。您可以重复使用此示例命令，直到操作完成：
+
[source, console]
----
tridentctl protect get resourcebackup -n <my_app_namespace> <my_backup_name>
----
. 确认备份是否成功：
+
[source, console]
----
kubectl describe resourcebackup <my_backup_name>
----


--
=====
====
.步骤 2：运行执行钩子
[%collapsible]
====
[role="tabbed-block"]
=====
.使用 CR
--
.步骤
. 创建自定义资源 (CR) 文件并将其命名为 `trident-protect-hook-run.yaml`。
. 配置以下属性以匹配您的Trident Protect 环境和集群配置：
+
** *metadata.name*: (_必填_) 此自定义资源的名称；请为您的环境选择一个唯一且有意义的名称。
** *spec.applicationRef*: (_必需_) 确保此值与您在步骤 1 中创建的 ResourceBackup CR 中的应用程序名称匹配。
** *spec.appVaultRef*: (_必需_) 确保此值与您在步骤 1 中创建的 ResourceBackup CR 中的 appVaultRef 匹配。
** *spec.appArchivePath*：确保此值与您在步骤 1 中创建的 ResourceBackup CR 中的 appArchivePath 匹配。
+
[source, console]
----
kubectl get backups <BACKUP_NAME> -n my-app-namespace -o jsonpath='{.status.appArchivePath}'
----
** *spec.action*: (_Required_) 一个字符串，指示执行钩子将采取什么操作，假设指定的任何执行钩子过滤器都匹配。可能值：
+
*** Snapshot
*** 备份
*** 还原
*** 故障转移


** *spec.stage*: (_Required_) 一个字符串，指示执行钩子应该在操作的哪个阶段运行。这次钩子运行不会在任何其他阶段运行钩子。可能值：
+
*** 预
*** 发布
+
YAML 示例：

+
[source, yaml]
----
---
apiVersion: protect.trident.netapp.io/v1
kind: ExecHooksRun
metadata:
  name: example-hook-run
spec:
  applicationRef: my-app-name
  appVaultRef: my-appvault-name
  appArchivePath: example-resource-backup
  stage: Post
  action: Failover
----




. 在用正确的值填充 CR 文件后，应用 CR：
+
[source, console]
----
kubectl apply -f trident-protect-hook-run.yaml
----


--
.使用 CLI
--
.步骤
. 创建手动执行钩子运行请求：
+
[source, console]
----
tridentctl protect create exechooksrun <my_exec_hook_run_name> -n <my_app_namespace> --action snapshot --stage <pre_or_post> --app <my_app_name> --appvault <my_appvault_name> --path <my_backup_name>
----
. 检查执行钩子运行状态。您可以重复运行此命令，直到操作完成：
+
[source, console]
----
tridentctl protect get exechooksrun -n <my_app_namespace> <my_exec_hook_run_name>
----
. 描述 exechooksrun 对象以查看最终详细信息和状态：
+
[source, console]
----
kubectl -n <my_app_namespace> describe exechooksrun <my_exec_hook_run_name>
----


--
=====
====